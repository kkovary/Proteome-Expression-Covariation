---
title: 'Combined effects of protein expression variance and correlation on multicomponent systems'

author:  

- name: Kyle M. Kovary
  affilnum: 1
  #email: kkovary@stanford.edu
  
- name: Mary N. Teruel
  affilnum: 1
  #email: mteruel@stanford.edu
  
affiliation:

- affilnum: 1
  affil: Department of Chemical and Systems Biology, Stanford University, Stanford, CA 94305, USA.
  
  
output:
  # word_document:
  # html_document:  
  pdf_document:
    fig_caption: yes
    fig_width: 7
    fig_height: 7
    keep_tex: yes
    number_sections: no
    template: manuscript.latex
    includes:
      in_header: header.tex
  
  
    
documentclass: article
capsize: normalsize
geometry: margin=1in
fontsize: 11pt
header-includes: 
  \usepackage{float} \floatplacement{figure}{H} 
  \newcommand{\beginsupplement}{\setcounter{table}{0}  \renewcommand{\thetable}{S\arabic{table}} \setcounter{figure}{0} \renewcommand{\thefigure}{S\arabic{figure}}}
spacing: doublespacing
bibliography: 
  - references.bib
  - knitcitations.bib
csl: cell.csl
abstract: Protein expression variation leads to phenotypic variance between cells. This has been demonstrated in cell signaling and differentiation decisions. Additionally coordinated expression of proteins between cells can tune signaling pathways either towards a more binary or analog modality. Though there is some evidence in bulk cell measurements and in bacteria that certain heteromeric subunits or metabolic pathways may be expressed in a coordinated fashion (i.e. operons in bacteria), there has not been a direct measurement of coordinated expression of proteins (independent of TFs) in metazoans (vertebrates?). Here, we measure cell-to-cell variability of relative protein abundance using quantitative proteomics of individual *Xenopus laevis* eggs and show that proteins involved in metabolic pathways or members of heteromeric complexes tend to have high correlations with other members of those pathways/complexes. Our previous work highlighted the fact that correlated expression increases the total variation of a pathway, so one would reason that certain pathways or complexes would need to compensate of this extra source of by reducing the variation of expression of these pathways or complexes. To test this we computed total variance score that took into account both the coefficient of variance and correlations between proteins in a pathway and found that the lower 10% of GO terms were highly enriched for metabolic pathways. When we looked at the relationship between CV and R between these GO terms we found a negative relationship between them, demonstrating that increased correlation needs to come at the expense of decreased variance. Simple molecular models of heteromeric complexes and metabolic pathways demonstrate that this tradeoff can result in higher efficiencies in both function and reduced energy waste. Together, our study argues for a control principle whereby coordinated expression of proteins in a pathway can require lower variance in order to reduce the overall pathway variance, enabling accurate control of active complexes or metabolic pathway activity.
---


```{r setup, include=FALSE, cache=FALSE, message = FALSE}

library(knitr)
library(tidyverse)
library(RColorBrewer)
#library(pheatmap)
library(ComplexHeatmap)
library(GGally)
library(VIM)
library(org.Xl.eg.db)
library(GO.db)
library(ggrepel)
library(plotly)
library(cowplot)
library(patchwork)
source("../functions.R")
library(knitcitations)
library(ggplotify)
library(latex2exp)
library(KEGG.db)
library(magick)

cleanbib()   
cite_options(citation_format = "pandoc")

#opts_knit$set(root.dir=normalizePath('../'))

### Chunk options: see http://yihui.name/knitr/options/ ###

## Text results
opts_chunk$set(echo = TRUE, warning = TRUE, message = TRUE, include = TRUE)

## Code decoration
opts_chunk$set(tidy = TRUE, comment = NA, highlight = TRUE)

## Cache
opts_chunk$set(cache = 2, cache.path = "output/cache/")

## Plots
opts_chunk$set(fig.path = "output/figures/")



```


```{r data_import, include=FALSE}

# Import Data
files = list.files('../TMTdata/', pattern = 'TargetPeptideSpectrumMatch', full.names = T)

for(i in seq_along(files)){
  if(i == 1 & exists('pepRaw')){
    rm(pepRaw)
  } 
  if(!exists('pepRaw')){
    pepRaw = read_tsv(file = files[i]) %>% mutate(file = files[i], massID = 1:nrow(.))
  } else{
    temp = read_tsv(file = files[i]) %>% mutate(file = files[i], massID = 1:nrow(.))
    colnames(temp) = colnames(pepRaw)
    pepRaw = rbind(pepRaw, temp)
    rm(temp)
  }
}
pepRaw <- pepRaw %>% dplyr::select(file, massID, everything()) %>% filter(!is.na(`126`), 
                                                                  `Quan Usage` == 'Use',
                                                                  Confidence != 'Low')

```

```{r data_organization, include=FALSE}
pepTidy <- pepRaw %>% 
  mutate(run = c('ctrl','a','b','c','d','e')[match(pepRaw$file, files)]) %>% 
  group_by(file, `Annotated Sequence`) %>% 
  mutate(pepID = letters[1:n()]) %>% ungroup() %>%
  dplyr::select(file, run, pepID, everything()) %>%
  gather(key = label, value = intensity, '126':'131') %>% 
  dplyr::select(run, label, intensity, everything(), -file) %>% 
  mutate(condition = ifelse(run == 'ctrl', 'ctrl',c('ctrl',0,20,40,60,80)[match(label,c(126:131))]),
         intensity = as.numeric(intensity)) %>% unite(peptide, c(`Annotated Sequence`,'pepID')) %>%
  dplyr::rename(Uniprot = `Master Protein Accessions`) %>% 
  unite(cell, c('run','label','condition'), remove = F) %>%
  dplyr::select(cell, run, label, condition, peptide, Uniprot, intensity)
```

```{r normalization, include=FALSE}
protImpute <- pepTidy %>% 
  group_by(peptide,run) %>% 
  mutate(intensity = intensity / intensity[label == "126"]) %>%
  ungroup() %>%
  filter(run != "ctrl", condition != "ctrl") %>%
  dplyr::filter(abs((intensity)) < 2*sd((pepTidy$intensity), na.rm = T)) %>%
  group_by(cell, run, label, condition, Uniprot) %>% 
  summarise(abundance = mean(intensity, na.rm = T)) %>% ungroup() %>%
  group_by(Uniprot) %>%
  mutate(abundance = abundance / mean(abundance, na.rm = T)) %>% 
  group_by(cell) %>% 
  mutate(abundance = abundance / mean(abundance, na.rm = T)) %>% 
  ungroup() %>% 
  dplyr::select(cell, Uniprot, abundance) %>% 
  spread(cell, abundance) %>%
  kNN(data = ., k = 1, impNA = TRUE) %>% as_tibble() %>% dplyr::select(Uniprot:e_131_80)

```

```{r summary_stats, include=FALSE}
protVar <- protImpute %>% gather(key = 'cell', value = 'abundance', 2:ncol(protImpute)) %>%
  separate(cell, into = c('run','label','condition'), remove = F) %>% 
  filter(condition != 'ctrl') %>% group_by(Uniprot) %>%
  summarise(var = var(abundance),
            sd = sd(abundance),
            mean = mean(abundance),
            cv = sd / mean)

cor = cor(t(log2(protImpute[c(1:ncol(protImpute))[-c(1,grep('ctrl',colnames(protImpute)))]])), use = 'pairwise.complete.obs')
colnames(cor) = protImpute$Uniprot
rownames(cor) = protImpute$Uniprot

cov = cov(t(log2(protImpute[c(1:ncol(protImpute))[-c(1,grep('ctrl',colnames(protImpute)))]])), use = 'pairwise.complete.obs')
colnames(cov) = protImpute$Uniprot
rownames(cov) = protImpute$Uniprot
```

```{r group_prots, include=FALSE, eval=FALSE}
# GO Terms
keys <- keys(org.Xl.eg.db, keytype = 'UNIPROT')

GO <- protImpute %>% dplyr::select(Uniprot) %>% dplyr::filter(Uniprot %in% keys) %>% 
  dplyr::mutate(GOterms = mapIds(org.Xl.eg.db, 
                     keys = Uniprot, 
                     keytype = 'UNIPROT', 
                     column = 'GOALL', 
                     multiVals = 'list'))

allGO <- unnest(GO, cols = GOterms) %>% nest(Uniprot = Uniprot) %>%
  rowwise() %>% mutate(n = length(unlist(Uniprot))) %>% ungroup() %>%
  mutate(name = mapIds(GO.db, 
                     keys = GOterms, 
                     keytype = 'GOID', 
                     column = 'TERM') %>% as.character(),
         ontology = mapIds(GO.db, 
                     keys = GOterms, 
                     keytype = 'GOID', 
                     column = 'ONTOLOGY') %>% as.character(),
         type = "GO") %>%
  rename(accession = GOterms) %>%
  dplyr::select(type, accession, name, ontology, everything())

# KEGG Pathways
kegg <- plyr::ldply(as.list(org.Xl.egPATH2EG),data.frame) %>% as_tibble() %>%
  rename(kegg_id = ".id", gene_id = "X..i..")

kegg_names <- plyr::ldply(as.list(KEGGPATHNAME2ID),data.frame) %>%
  rename(kegg_name = ".id",
         kegg_id = "X..i..")

kegg <- protImpute %>% dplyr::select(Uniprot) %>% filter(Uniprot %in% keys) %>% 
  mutate(KEGG = mapIds(org.Xl.eg.db, 
                     keys = Uniprot, 
                     keytype = 'UNIPROT', 
                     column = "PATH", 
                     multiVals = 'list'))

allKEGG <- unnest(kegg, cols = KEGG) %>% nest(Uniprot = Uniprot) %>%
  rowwise() %>% dplyr::mutate(n = length(unlist(Uniprot))) %>% ungroup() %>%
  dplyr::mutate(name = kegg_names$kegg_name[match(KEGG,kegg_names$kegg_id)],
         type = "KEGG",
         ontology = NA) %>% rename(accession = KEGG) %>%
  dplyr::select(type, accession, name, ontology, Uniprot, n)



allGroups <- rbind(allGO, allKEGG)

# Calculate summary variables
corVector <- function(uniprotList, corMat){
  targets = uniprotList %>% unlist()
  temp = corMat[rownames(corMat) %in% targets,colnames(corMat) %in% targets]
  temp[lower.tri(temp, diag = F)]
}

selectCV <- function(x){
  protVar %>% filter(Uniprot %in% unlist(x)) %>% 
    dplyr::select(cv) %>% as_tibble() %>% as.list()
}

selectSD <- function(x){
  protVar %>% filter(Uniprot %in% unlist(x)) %>% 
    dplyr::select(sd) %>% as_tibble() %>% as.list()
}

allGroups <- allGroups %>% group_by(accession) %>% 
  dplyr::mutate(cors = corVector(Uniprot, cor) %>% as_tibble() %>% as.list(),
                covs = corVector(Uniprot, cov) %>% as_tibble() %>% as.list(),
                cv = selectCV(Uniprot),
                sd = selectSD(Uniprot)) %>% ungroup() %>%
  rowwise() %>% mutate(medCors = mean(cors, na.rm = TRUE),
                       medCV = mean(cv, na.rm = TRUE),
                       medSD = mean(sd, na.rm = TRUE)) %>%
  ungroup() %>%
filter(n > 3,
       !is.na(medCors),
       !is.na(medCV))


```

```{r total_var, include=FALSE, eval=FALSE}
groupCor <- function(x){
  geneList <- unlist(x)
  
  if (length(geneList) > 1) {
    protCombs <- t(combn(geneList, 2))
    return(sqrt(sum(totVarPair(protCombs))))
  } else{
    return(as.numeric(protVar[protVar$Uniprot == geneList[1], 2]))
  }
}

totVarPair <- function(x){
  A <- as.character(x[1])
  B <- as.character(x[2])
  varA <- as.numeric(protVar[protVar$Uniprot == A, 3])
  varB <- as.numeric(protVar[protVar$Uniprot == B, 3])
  corAB <- cor[A,B]
  tot <- varA^2 + varB^2 + 2*corAB*varA*varB
  return(tot)
}

totVarGroup <- function(x){
  geneList <- unlist(x)
  
  if (length(geneList) > 1) {
    protCombs <- t(combn(geneList, 2))
    return(sqrt(sum(apply(protCombs, 1, function(x) totVarPair(x)))))
    #return(sqrt(sum(totVarPair(protCombs))))
  } else{
    return(as.numeric(protVar[protVar$Uniprot == geneList[1], 2]))
  }
  
}

allGroups <- allGroups %>% filter(!is.na(accession)) %>% rowwise() %>%
  mutate(totVar = totVarGroup(Uniprot),
         normVar = totVar / n) %>%
  filter(n > 3) %>% ungroup()

allGroups <- allGroups %>% mutate(interval = cut_number(normVar, n = 7)) %>%
  mutate(interval = ifelse(interval == levels(interval)[1],
                           "low",
                           ifelse(interval == levels(interval)[7],
                                  "high",
                                  "mid")))

saveRDS(allGroups,"allGroups.RDS")
```


*Keywords*: single cell, proteomics, stochasticity

\doublespace

\bleft

\justify


# Introduction

The coordinated expression of proteins is vital for cellular function, from maintaining a dynamic steady state to differentiation of cells into specialized types and tissues. This coordinated regulation of protein abundance is subject to stochastic expression levels, and modules (pathways, complexes, etc.) have varying tolerances of noise for proper function ranging from precise stoichiometric coordination, to high levels of noise that can result in heterogeneous responses of homogeneous cell populations to identical stimuli `r citep("10.1073/pnas.1615660114")`. The ability to regulate coordinated expression has been demonstrated to occur via transcription (transcription factors, chromatin regulation), translation (specialized ribosomes, mRNA structure/modifications), and degradation (E3 ligases), all of which are subject to stochastic expression and interactions. This noise has been shown be utilized by cells for bet hedging strategies as well as tissue size maintenance (more concrete examples to come). Additionally, the combination of variability and coordinated expression (correlation) of proteins can lead to increased population level control in binary decisions, and a decreased ability to execute analog signaling `r citep(c("doi.org/10.15252/msb.20177997", "10.1073/pnas.1615660114"))`.

There have been numerous studies, both targeted and unbiased, of coordinated protein expression or expression variation independently that have shown the important impacts of these parameters on cellular function. However, both of these parameters (variation and correlation) act together to determine the total variance of a system. To systematically assess these properties of single cells at a large scale, we conducted shotgun proteomics analyses on *Xenopus laevis* eggs during their first cell cycle. We have found this model to be ideal at this nascent stage of the single cell proteomics field because of their large size and tractability. An advantage of this approach is that we can get around much of the signal to noise issues that accompany studying single cells caused by low sample protein levels. Additionally, at this stage of development transcription is restricted, allowing for insights into non-transcriptional control of protein expression. By utilizing isobaric tagging and shotgun mass spectrometry we were able to measure >1000 proteins across 25 single cells in 5 mass spectrometry runs. 

With this data set we have been able to, for the first time, gain insights into the relationship between protein expression variance, coordinated protein expression, and total variance within modules at a proteomic scale in single cells. We identified classes of proteins that include heteromeric complexes and metabolic pathways that are expressed in such a way that the increase in total variance of the system caused by high coordinated expression of proteins is offset by decreased variation, allowing for modules that rely on stoichiometric expression and low level of variance to maintain a low level of total system variance. By counter balancing coordinated expression (correlation) of proteins in a module with low expression variance, cells are able to decrease the total variance of a given complex or pathway. This elegant balancing act may allow for finer control of metabolic throughput and controlling the number of potentially formed complexes though stoichiometric control.

# Results

## Single cell proteomics reveals global protein expression variability and coordinated expression between protein pairs.

The specific requirements for coordinated protein expression of pathways or complexes can vary, with some requiring strict stoichiometric regulation and others having much more relaxed requirements. Strict stoichiometry scenarios require coordinated expression of proteins (Figure 1A, top), and others can have uncoordinated expression (Figure 1A bottom). At the single cell level, coordinated expression will result in a high correlation coefficient, whereas un-coordinated expression will result in a low correlation coefficient (Figure 1B). Even when the expression variation (standard deviation or coefficient of variation) and abundance is identical between these two scenarios, the total variance of a pathway or complex can be significantly different due to the variance sum law: $var\left(\sum_{i=1}^n X_{i}\right) = \sum_{i=1}^{n} var(X_{i}) + 2\sum_{i,j:i<j}^{n} cov(X_{i},X_{j})$ (Figure 1C). Our previous work has shown that this effect is important in single cell pathway activation dynamics `r citep("doi.org/10.15252/msb.20177997")`.

In order to study the relationship between protein expression variance and co-expression (correlated expression) of cellular pathways and complexes at the proteome level, we utilized *Xenopus laevis* eggs as a single cell model. Activated *Xenopus laevis* eggs were collected at 5 time points across the first cell cycle (0, 20, 40, 60, and 80 minutes), with 5 eggs at each time point (Fig 1D). Using TMT multiplexing and mass spectrometry, we were able to determine the relative abundance of more than 1300 proteins in single cells. Expression of these proteins across the time course of the cell cycle showed no dynamic patterns, revealing that these highly expressed proteins are likely not regulated by cell cycle processes. Additionally, a PCA analysis of these eggs showed no discernible clustering on cell cycle time (Fig S2).

To determine the expression variability for the measured proteins between single cells, we calculated the variance and coefficient of variation (CV) across all samples. This showed a wide range of variation containing multiple distributions (Fig 1E), many of which are consistent with our previous study of variation using targeted mass spectrometry (Fig S2). An added benefit to measuring these proteins in parallel is that we are able to calculate coordinated expression of protein pairs at single cell resolution. Using the Pearson correlation coefficient, we were able to determine the coordinated expression of nearly 2 million protein pairs (Fig 1F-G). The distribution of correlation coefficients fit a normal distribution centered around 0, with the majority of protein pairs appearing to not show significant co-regulation. However, there appear to be a significant number of protein pairs containing high correlation coefficients, and a clustered heat map shows that many highly co-regulated pairs cluster together (Fig 1G).


## Variance sum law reveals modules that utilize a trade-off between protein co-expression and noise

Multicomponent modules such as heteromeric protein complexes and metabolic and signaling pathways have a certain tolerance for noise. Two components of the noise of these systems are the expression variance of the individual proteins, as well as the correlation or co-variance of expression between the proteins. This means that if a group of proteins have a positive correlation, then the total variance will be higher than if there was no correlation. This single cell proteomics data set gave us an excellent opportunity to see how variance and co-expression of proteins are related in low variance and high variance modules. The total variance of a module can be calculated using the variance sum law, where for a group of proteins $X_{1},\dotsc,X_{n}$, the total variance of the group is:
$$\sigma_{{}_{total}}^2 = \sum_{i=1}^{n} \sigma_{X_{i}}^2 + 2\sum_{i,j:i<j}^{n} \rho(X_{i},X_{j})\sigma_{X_i}\sigma_{X_j}$$

To categorize the measured protein expression data into modules, we utilized GO term and KEGG pathway annotations. Since pathways and complexes have varying numbers of proteins, and the number of proteins in a module is highly influential on the total variance sum, we normalized the total variance sum by the number of components (Fig. xA and xB) to eliminate this confounding dependency. With the normalized total variance metric, we could separate modules into high and low variance categories (Fig 2A). Since co-expression of proteins (positive correlation between protein expression) increases the total variance, we expected to see the high variance modules to be enriched for high levels of both protein expression variance and co-expression (Fig 1B and 1C, red). However, we were surprised to see that the low variance modules were also enriched for high levels of co-expression of proteins, with some of the mean correlation coefficients of modules as high as those in the high variance category (Fig 1B, orange shaded region).

We wondered how these protein modules dealt with the increased variance load caused by the high numbers of correlated proteins, so we looked at the pairwise relationship between the mean variance of the modules and the mean correlation coefficients (Fig 2D and S1). The low variance modules uniquely showed a significant negative correlation (R = 0.49) between these two metrics, showing that for modules that enforce a low level of total variance, co-expression of proteins within that module is offset by lower expression variance.

## Enforcement of a trade-off between protein co-expression and noise increases efficiency of heteromeric protein complexes and metabolic pathways

Interestingly, we saw the low total variance and high coordinated expression sub population contained many metabolic pathways as well as multisubunit complexes, while the high total variance and high coordinated expression sub-population contained many signalling pathways (Fig. 2D, Fig. 3E-H). Previous studies have shown that protein complex components are produced stoichiometricly `r citep("doi.org/10.1016/j.cels.2018.11.003")` across eukaryotic species and that co-expression of pathway specific enzymes are tightly regulated post-transcriptionally across species `r citep("doi.org/10.1016/j.cell.2018.03.007")`. This led us to wondered what the implications were for the synergy of maintaing low total variance with high levels of co-expression of the members of protein complexes and metabolic pathways.

To test why complexes observed in our data set and others, (i.e. core members of the ribosome (Fig 4A)), coordinate co-expression and expression variation, we imagined an idealized 10 member heteromeric complex (Fig 4B). Coordinated expression could allow for tight control of the total number of assembled complexes. However, this on it's own is not sufficient since high levels of individual protein variance would result in an increased number of partially assembled complexes. In this idealized complex, we titrated the correlation coefficients between all 10 members along with the individual expression variation and saw that increased correlations and decreasing variance had a synergistic effect in allowing for the control of the total number of fully assembled complexes (Fig 4C.). Additionally, there is a large regime with high correlations and low variation that allow for low total variance of the system.

We also observed a number of metabolic pathways that had similar variation and correlation properties as the protein complexes, such as the pentose phosphate pathway and glycolysis. Both of these pathways have a large number of reversible enzymes. For a reversible enzymatic pathway, the concentrations of the enzymes dictate the rate of the reaction, and the concentrations of the reaction products relative to the substrates can dictate the direction of the reaction equilibrium. Therefore, strict balance of the concentration of enzymes using low levels of variance and strict control of the relative abundances of the enzymes is a potentially important step in regulating metabolic pathway output. To test this hypothesis, we constructed an idealized metabolic model (or a physiological model??) and tested the ability of the pathway to maximize output (Fig 5x). (haven't done this, would like feedback / help).




## Discussion

\newpage

# Figures

```{r figure_1, echo=FALSE, fig.height=4.5, fig.width=6, message=FALSE, warning=FALSE, fig.cap=fig_legend_1}
allGroups <- readRDS("allGroups.RDS")

set.seed(41)

low_cor <- corProts(2, 100, 0, 100, 30)
low_cor <- low_cor %>% as_tibble() %>% mutate(cor = "low_cor", time = 1:nrow(low_cor)) %>%
  rename(ProtA = "V1", ProtB = "V2")

high_cor <- corProts(2, 100, 0.8, 100, 30)
high_cor <- high_cor %>% as_tibble() %>% mutate(cor = "high_cor", time = 1:nrow(high_cor)) %>%
  rename(ProtA = "V1", ProtB = "V2")

p1 <- rbind(low_cor, high_cor) %>% pivot_longer(ProtA:ProtB, names_to = "protein", values_to = "abundance") %>%
  ggplot(., aes(x = time, y = abundance, color = protein)) + 
  #annotate("rect", xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, aes(fill = cor)) +
  #geom_rect(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf, aes(fill = cor, color = NA), alpha = 0.002) +
  geom_path() +
  facet_wrap(~cor, ncol = 1) +
  scale_color_manual(values = c("#d53e4f","#3288bd")) +
  theme_minimal() +
  theme(legend.position = "none")

p2 <- rbind(low_cor, high_cor) %>% pivot_longer(ProtA:ProtB, names_to = "protein", values_to = "abundance") %>%
  ggplot(., aes(x = protein, y = abundance, color = protein)) + 
  geom_boxplot() + facet_wrap(~cor, ncol = 1) +
  theme_minimal() +
  theme(legend.position = "none")

p3 <- rbind(low_cor, high_cor) %>%
  ggplot(., aes(x = ProtA, y = ProtB, color = cor)) + geom_point() +
  scale_color_manual(values = c("#d53e4f","#3288bd")) +
  stat_ellipse() +
  theme_minimal() +
  theme(legend.position = "none")

p4 <- tibble(cor = c("High","Low"),
       var_sum = c(sqrt(30^2 + 30^2 + 2*0.8*30^2),
                   sqrt(30^2 + 30^2 + 2*0*30^2))) %>%
  ggplot(., aes(x = cor, y = var_sum, fill = cor)) + geom_bar(stat = "identity") +
  scale_fill_manual(values = c("#d53e4f","#3288bd")) +
  theme_minimal() +
  theme(legend.position = "none")

# Variation histogram
p5 <- ggplot(protVar, aes(x = cv)) + 
  geom_histogram(bins = 200) + xlim(0,.8) + theme_minimal() +
  theme(legend.position = "none")

# Correlation matrix
cor = cor(t(log2(protImpute[c(1:ncol(protImpute))[-c(1,grep('ctrl',colnames(protImpute)))]])), use = 'pairwise.complete.obs')
colnames(cor) = protImpute$Uniprot
rownames(cor) = protImpute$Uniprot

p6 <- tibble(R = as_vector(cor[lower.tri(cor)])) %>%
  ggplot(., aes(x = R)) + geom_histogram(bins = 1000) + xlim(-1,1) +
  theme_minimal()

p7 <- as.ggplot(
  Heatmap(cor, 
        col = rev(colorRampPalette(brewer.pal(11, 'RdBu'))(201)),
        heatmap_legend_param = list(title = "R"),
        show_column_dend = FALSE,
        show_row_dend = FALSE,
        show_column_names = FALSE,
        show_row_names = FALSE,
        use_raster = TRUE,
        raster_quality = 1)
  )

p8 <- cowplot::ggdraw() + cowplot::draw_image(magick::image_read_svg("../images/egg_cartoon.svg"))

# pp1 <- p1 + p2 + plot_layout(widths = c(3,1))
# pp2 <- p3 + p4
# 
# pp1 / pp2 + plot_annotation(tag_levels = "A") & theme(legend.position = "none")

top <- p1 + p3 + p4 + plot_layout(nrow = 1,
                                  widths = c(1/3,1/3,1/6),
                                  heights = c(1,1,1))
bottom <- p8 + p5 + p6 + p7 + plot_layout(nrow = 1,
                                          widths = c(2,1,1,3),
                                heights = c(2,1,1,2))

top / bottom + plot_layout(nrow = 2,
                           heights = c(1,0.8)) +
  plot_annotation(tag_levels = "A")

fig_legend_1 <- c("A) Simulated expression of two proteins over time in a single cell with a mean of 100 and a standard deviation of 30 with expression correlations of 0 and 0.8. B) Pairwise plots of the two proteins in the single cells between uncorrelated and correlated scenarios. C) The total variance between the uncorrelated and correlated scenarios from A and B. D) To measure protein expression variance and coordinated expression, 25 eggs at 5 time points during the first cell cycle were analyzed with multiplexed shotgun mass spectrometry. E) Histogram of the coefficient of variation of all measured proteins. F) Histogram of the pairwise correlation coefficients between all measured proteins. G) Heat-map of the pairwise correlation coefficients between all measured protein pairs.")

```

\newpage

```{r figure_2, echo=FALSE, fig.height=7, fig.width=6, message=FALSE, warning=FALSE, eval=TRUE, fig.cap=fig_legend_2}
p1 <- ggplot(allGroups, aes(x = normVar, fill = interval)) + 
  geom_histogram(data = filter(allGroups, interval == "mid"),bins = 50) + 
  geom_histogram(data = filter(allGroups, interval == "low"),bins = 50) + 
  geom_histogram(data = filter(allGroups, interval == "high"),bins = 50) + 
  theme_minimal() +
  scale_fill_manual(values = c("#d53e4f","#3288bd","grey")) +
  xlab("Normalized Variation") + ylab("Number") +
  theme(legend.position = "none")

interesting_groups_low <- c("03010","00030","GO:0046496","00071",
                            "GO:0006096","GO:0015934","GO:0019843",
                            "00051","GO:0042555","04012")

interesting_groups_high <- c("GO:0042995","03008","GO:0007264","GO:0005885",
                             "GO:0007166","04150","GO:0035556","GO:0016791","GO:0007165")

interesting_groups <- c(interesting_groups_low, interesting_groups_high)

p2 <- ggplot(filter(allGroups, n > 5), aes(x = medCors, y = medCV, color = interval)) +
  geom_point(data = filter(allGroups, interval == "mid", n > 4),
             size = 2, alpha = 0.5, stroke = 0) +
  geom_point(data = filter(allGroups, interval != "mid", n > 4),
             size = 3, alpha = 0.75, stroke = 0) +
  geom_label_repel(data = filter(allGroups, accession %in% interesting_groups),
                  aes(label = name),
                  colour = 'black',
                  size = 1.5,
                  force = 5,
                  box.padding = 1) +
  #coord_cartesian(ylim=c(-10,10)) +
  theme_minimal() +
  theme(legend.position = "bottom") +
  scale_color_manual(values = c("#d53e4f","#3288bd","grey")) +
  xlab("Mean Correlation") + ylab("Mean Coefficient of Variation")


p3 <- ggplot(allGroups, aes(x = medCors, fill = interval)) +
  annotate("rect", xmin = 0.15, xmax = Inf, ymin = 0, ymax = Inf, fill = "orange", alpha = 0.5) +
  geom_density(data = filter(allGroups, interval != "mid"), alpha = 0.75, color = NA) +
  geom_density(data = filter(allGroups, interval == "mid"), alpha = 0.5, color = NA) +
  theme_minimal() +
  scale_fill_manual(values = c("#d53e4f","#3288bd","grey")) +
  theme(legend.position = "none")

p4 <- ggplot(allGroups, aes(x = medCV, fill = interval)) +
  geom_density(alpha = 0.75, color = NA) +
  theme_minimal() +
  scale_fill_manual(values = c("#d53e4f","#3288bd","grey")) +
  theme(legend.position = "none")

# p5 <- rbind(mutate(allGroups, interval = "mid", name = "all"),
#       filter(allGroups, accession %in% interesting_groups)) %>%
#   dplyr::select(-Uniprot,-covs,-cv,-type,-ontology) %>%
#   unnest(cols = "cors") %>%
#   ggplot(., aes(x = fct_reorder(name,rank(interval)), y = cors, fill = interval)) +
#   #geom_boxplot(notch = FALSE, alpha = 0.75, outlier.size = 0) +
#   geom_violin() +
#   scale_fill_manual(values = c("#d53e4f","#3288bd","grey")) +
#   coord_flip() +
#   scale_x_discrete(labels = function(x) str_wrap(x, width = 15)) +
#   theme_minimal() +
#   theme(text = element_text(size = 6),
#         axis.title.y=element_blank())

# p6 <- p2 + plot_spacer() + plot_layout(widths = c(1,0.5))
#   
# (p1 + p3 + p4) / p6 + plot_layout(heights = c(1,5)) +
#   plot_annotation(tag_levels = "A") &
#   theme(legend.position = "none")

left <- (p1 / p3 / p4) + plot_layout(ncol = 1)

wrap_plots(left, p2) + plot_layout(widths = c(1,3)) +
  plot_annotation(tag_levels = "A")

fig_legend_2 <- c("A) Histogram of the normalized variation values across all of the GO terms and KEGG pathways. The bottom and top ~15% are colored blue and red respectively. B) Distributions of the mean correlation coefficient across all groups of proteins. Both the top and bottom 15% of normalized variation groups had peaks of high levels of mean correlation coefficients. C) Distributions of the mean coefficient of variation across all groups of proteins. The top and bottom ~15% of normalized variation groups were largely separated. D) Pairwise plot between the mean correlation and mean coefficient of variation within each GO term and KEGG pathway with color coding from A. Interestingly, both the top and bottom 10% of normalized variation have groups of proteins with high levels of correlation, despite high correlation adding to total variance. In the lowest 10% of normalized variation groups there appears to be a negative correlation between mean correlation and variation.")

```

\newpage

```{r figure_3, echo=FALSE, fig.height=4, fig.width=7, message=FALSE, warning=FALSE, eval=TRUE, fig.cap=fig_legend_3}
plots <- 1:4
for(i in 1:length(plots)){
  assign(paste0("p",plots[i]), cor_rug_plot(interesting_groups_low[i], "#3288bd"))
}

plots <- 5:8
for(i in 1:length(plots)){
  assign(paste0("p",plots[i]), cor_rug_plot(interesting_groups_high[i], "#d53e4f"))
}

left <- p1 + p2 + p3 + p4 + plot_layout(nrow = 1)

right <- p5 + p6 + p7 + p8 + plot_layout(nrow = 1)

wrap_plots(left, right) + 
  plot_annotation(tag_levels = "A") + 
  plot_layout(nrow = 2)

fig_legend_3 <- c("Density plots of correlation coefficients select protein groups color coded by low (blue) and high (red) normalized protein variance, with the distribution of all measured correlation coefficients colored in grey (rug plot to show the measured correlations coefficients shown on plot). Below each density plot is a box plot.")
```

\newpage

```{r figure_4, echo=FALSE, fig.height=6, fig.width=6, message=FALSE, warning=FALSE, eval=TRUE, fig.cap=fig_legend_4}
library(circlize)

#allGroups[grep("large ribo",allGroups$name),]
prots <- allGroups %>% filter(accession == "GO:0015934") %>% pull(Uniprot) %>% unlist() %>% as.vector()
mat <- cor[prots,prots]
rownames(mat) <- mapIds(org.Xl.eg.db, keys = rownames(mat), keytype = 'UNIPROT', column = 'SYMBOL')


p1 <- as.ggplot(
  Heatmap(
    mat,
    column_title = "Large ribosomal subunit",
    column_title_gp = gpar(fontsize = 5, fontface = "bold"),
    col = colorRamp2(seq(-1,1,0.01), rev(colorRampPalette(brewer.pal(11, 'RdBu'))(201))),
    heatmap_legend_param = list(title = "R"),
    row_names_gp = gpar(fontsize = 4),
    column_names_gp = gpar(fontsize = 4),
    show_column_dend = FALSE,
    show_row_dend = FALSE,
    show_column_names = TRUE,
    show_row_names = TRUE,
    #cell_fun = function(j, i, x, y, width, height, fill) {grid.text(sprintf("%.1f", mat[i, j]), x, y, gp = gpar(fontsize = 1))},
    use_raster = FALSE
  )
)


# Plot of max number of complete complexes
cors <- seq(0,1,0.02)
vars <- rev(seq(0,1,0.02))

corVarMat <- matrix(data = NA, ncol = length(cors), nrow = length(vars))
colnames(corVarMat) <- cors
rownames(corVarMat) <- vars

# Percent of potentially complete complexes

corVarMat <- sapply(1:length(cors), function(i) {
  sapply(1:length(vars), function(j) {
    perc <- corProts(nProt = 10, nCell = 10000, R = cors[i], mean = 1000, sd = 1000*vars[j])
    mean(apply(perc, 1, function(x) min(abs(x)) / max(abs(x))), na.rm = T)
    #corVarMat[j,i] <- perc
  })
})

x <- cbind(vars, corVarMat)
colnames(x) <- c("vars",as.character(cors))
x <- x %>% as_tibble() %>% gather(key = R, value = percent, 2:ncol(x)) %>% mutate(R = as.numeric(R)) %>%
  rename_(CV = vars)

p2 <- ggplot(x, aes(x = CV, y = percent, colour = R, group = as.factor(R))) + 
  geom_path() + 
  scale_x_reverse() + 
  scale_color_viridis_c() +
  theme_minimal()

cors <- seq(0,1,0.01)
vars <- rev(seq(0,0.5,0.005))

totVarMat <- sapply(1:length(cors), function(i) {
  sapply(1:length(vars), function(j) {
    (10*vars[j]^2 + 10*2*cors[i]*vars[j]) / 10
    #corVarMat[j,i] <- perc
  })
})

rownames(totVarMat) <- vars
colnames(totVarMat) <- cors

col_fun <- colorRamp2(seq(range(totVarMat)[1],
                         range(totVarMat)[2],
                         range(totVarMat)[2] / 150), 
                     wesanderson::wes_palette("Zissou1", 
                                              n = 151, 
                                              type = "continuous"))

p3 <- as.ggplot(Heatmap(totVarMat,
        col = col_fun,
        cluster_rows = FALSE,
        cluster_columns = FALSE,
        show_column_names = FALSE,
        show_row_names = FALSE,
        border = NA,
        column_title = "R",
        row_title = "CV",
        heatmap_legend_param = list(title = "Norm Var"),
        row_names_gp = gpar(fontsize = 5),
        column_names_gp = gpar(fontsize = 5)))

p4 <- cowplot::ggdraw() + cowplot::draw_image(magick::image_read_svg("../images/complex_cartoon.svg"))

bottom <- p2 + p3 + plot_layout(widths = c(1,2))
(p1 + p4) / bottom + 
  plot_annotation(tag_levels = "A")


fig_legend_4 <- c("A) A representative heat-map of one of the low normalized variation groups with high levels of correlated proteins (Large ribosomal subunit). B) A simple model showing the percent of potentially assembled subunits of an idealized heteromeric 10 subunit complex. Both the variation of expression between the subunits as well as the coordinated expression between them can effect the percent of maximum assembled complexes. C) Heat-map showing the total variance as a function of coefficient of variation and correlation from the idealized model in B).")
```

\newpage

# Supplementary material {-}

\beginsupplement
```{r sup_fig_1, echo=FALSE, fig.height=2, fig.width=6, message=FALSE, warning=FALSE, fig.cap=sup_fig_legend_1}
allGroups %>% filter(n > 4) %>%
  ggplot(., aes(x = medCors, y = medCV, color = interval)) + 
  geom_point() + 
  scale_color_manual(values = c("#d53e4f","#3288bd","grey")) +
  stat_summary(fun.data=mean_cl_normal) + 
  geom_smooth(method='lm', formula= y~x, color = "black") +
  facet_wrap(~interval, scales = "free", nrow = 1) +
  theme_minimal() +
  theme(legend.position = "none")

sup_fig_legend_1 <- c("Pairwise plots of the mean correlation coefficient and mean coefficient of variation of protein groups with linear fit. The low variance protein groups have a significant negative correlation between these two variables, showing that for protein modules that require low variance and high co-expression, showing that these two parameters... R (high, low, med) = (0.057, -0.485, 0.071)")
```

\newpage

# Methods

## Collection and activation of Xenopus laevis eggs:

Xenopus egg extracts were prepared based on modifications of a previous protocol `r citep("10.1371/journal.pbio.1001788")`. All of the animal protocols used in this manuscript were approved by the Stanford University Administrative Panel on Laboratory Animal Care. To induce egg laying, female Xenopus laevis were injected with human chorionic gonadotropin injection the night before each experiment. To collect the eggs, the frogs were subjected to pelvic massage, and the eggs were collected in 1X Marc’s Modified Ringer’s (MMR) buffer (0.1 M NaCl, 2 mM KCl, 1 mM MgCl2, 2 mM CaCl2, 5 mM HEPES, pH 7.8). To remove the jelly coat from the eggs, they were placed in a solution of 2% cysteine in 1× MMR buffer for 4 min and gently agitated, after which they were washed four times with 1× MMR buffer. To activate the cell cycle, eggs were placed in a solution of 0.5 $\mu$g/ml of calcium ionophore A23187 (Sigma) and 1X MMR buffer for 3 min, after which they were washed four times with 1× MMR buffer. Single eggs were collected at their respective time-points and placed into 600uL tubes and snap frozen in liquid nitrogen before being stored at 80°C.

## Sample preparation for mass spectrometry:

Single eggs were lysed mechanically by pipetting the egg in 100$\mu$L of lysis buffer (100 mM NaCl, 25 mM Tris pH 8.2, Complete EDTA- free protease inhibitor cocktail (Sigma). The lysate was then placed in a 400 uLnatural polyethylene micro-centrifuge tube (E&K
Scientific #485050) and spun at 15,000 g in a right angle centrifuge (Beckman Microfuge E) at 4°C for 5 min. The lipid layer was removed by using a razor blade to cut the tube off just beneath it, and the cytoplasmic fraction was pipetted into a 1.5-ml protein LoBind tube (Fisher Scientific #13-698-794), being careful to leave the yolk behind. To precipitate the proteins from the cytoplasmic fraction, 1 ml of ice cold acetone was added to each sample and placed at 20°C overnight. To collect precipitated proteins, the samples were centrifuged at
18,000 g for 20 min at 4°C. Acetone was decanted, and the protein pellets were resolubilized in 25$\mu$L of 8 M urea. To fully solubilize the protein pellet, the samples were placed in a shaker for 1 h at room temperature. The samples were then diluted to 2 M urea with 50 mM ammonium bicarbonate to a 100$\mu$L volume, after which protein concentration was measured in duplicate with a BCA assay by taking two 10$\mu$L aliquots of each sample. The proteins in the remaining 80$\mu$L of sample volume were reduced with 10 mM TCEP and incubated for 30 min at 37°C, then alkylated with 15 mM iodoacetamide and incubated in the dark at room temperature. 

Next, the samples were diluted to 1 M urea with 50 mM ammonium bicarbonate. Trypsin (Promega #V5113) was then added at a ratio of 10 ng trypsin per 1ug protein (no < 500 ng was added to a sample). The trypsin digestion was carried out at 37°C for 12–16 h. To stop the trypsin, formic acid (Fisher #A117-50) was added at a ratio of 3$\mu$l per 100$\mu$l of sample to bring the pH down to < 3.

Peptides were cleaned up using an Oasis HLB uElution plate (Waters), equilibrated, and washed with 0.04% trifluoroacetic acid in water, and eluted in 80% acetonitrile with 0.2% formic acid. All solutions used are HPLC grade. Samples were then lyophilized. To remove any variance produced by phosphorylated peptides, the samples were phosphatase-treated. Peptides were resolubilized in 50$\mu$L of 1X NEBuffer 3 (no BSA), and calf intestinal alkaline phosphatase (NEB #M0290S) was added at a ratio 0.25 units per lg of peptide and incubated for 1 h at 37°C. The peptides were cleaned up again according to steps described above. Peptides were resolubilized in 2% acetonitrile and 0.1% formic acid before MS analysis.

## Mass spectrometry data collection:

Ask SUMS for details

## Mass spectrometry data analysis:

Ask SUMS for details

## Data processing:

To minimize the effects of non-biological variance, a correction factor was used to correct for these biases. First, each peptide was normalized by the median across all of the samples. Second, the vector of all peptides for each cell was divided by the median value across all peptides. Before peptides were used to estimate protein abundance, highly variable peptides needed to be filtered out. Peptides were grouped by their master UniProt accession number, and all peptides whose log transformed values were more than 2$\sigma$ away from the mean were discarded. Next, protein abundances were estimated by taking the median normalized value for each peptide for a protein in each sample. Missing protein levels were imputed using the k-nearest neighbors algorithm, with k being set to 1 and the similarity measure for distance the Gower’s distance between the proteome vectors.

\clearpage

# References

```{r write_citations, cache=FALSE, include=FALSE}
write.bibtex(file="knitcitations.bib")
```

<div id = "refs"></div>

\eleft


\clearpage

```{r sessioninfo, echo = FALSE, eval = TRUE}
# set eval = FALSE if you don't want this info (useful for reproducibility) to appear 
sessionInfo()
```

